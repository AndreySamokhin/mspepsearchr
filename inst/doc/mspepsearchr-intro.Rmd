---
title: "Introduction to mspepsearchr"
author: "Andrey Samokhin"
date: 2025-11-08
output:
  rmarkdown::html_vignette:
    css: style.css
vignette: >
  %\VignetteIndexEntry{Introduction to mspepsearchr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr_setup, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.align = 'center',
fig.height = 3.5,
fig.width = 4.5
)
```

``` {r setup, include = FALSE}
library(mspepsearchr)
r_info <- paste0("`", "mspepsearchr_", packageVersion("mspepsearchr"), "`")
```



## Overview

### The MSPepSearch tool

MSPepSearch is a command-line interface (CLI) tool developed by NIST. It allows
users to perform batch library searches against mass spectral libraries in NIST
format. However, its usage can be challenging, since the CLI command may be long
and contain more than a dozen flags, as demonstrated below.

```{r cli_call_example, include = FALSE, eval = FALSE}
# jobs <- .PrepareJobs(
#   spectra = "test.msp",
#   libraries = c("C:/NIST23/MSSEARCH/mainlib/", "C:/NIST23/MSSEARCH/replib/"),
#   algorithm = "identity_normal",
#   presearch = "default",
#   valid_presearch_vals = "default",
#   addl_columns = c("/OutRevMF", "/OutMW", "/OutCAS", "/OutChemForm", "/OutIK")
# )
# cat(paste(c("<path>\\MSPepSearch64.exe", jobs[[1L]]$cli_args),
#           collapse = " "))
```

```
# Example command that performs library searches for all mass spectra in
# 'test.msp' against the 'mainlib' and 'replib' sub-libraries using the
# 'Identity EI Normal' algorithm. Results are written to
# 'library_search_results.tsv'. For each candidate, additional information such
# as molecular weight, CAS numbers, molecular formula, etc. is included.

<path>\MSPepSearch64.exe \
Id \
/MAIN <path>\NIST23\MSSEARCH\mainlib \
/REPL <path>\NIST23\MSSEARCH\replib \
/INP <path>\test.msp \
/OUTTAB <path>\library_search_results.tsv \
/HITS 100 \
/All \
/OutRevMF \
/OutMW \
/OutCAS \
/OutChemForm \
/OutIK
```

Search algorithms and options (e.g., presearch) are typically encoded as single
letters, either uppercase or lowercase, which makes preparing commands manually
error-prone. In the example above, `I` corresponds to the 'Identity EI Normal'
algorithm, and `d` represents the 'Default Presearch'.

MSPepSearch outputs results in a tab-separated values (TSV) format. While R
provides convenient tools for reading such tables, additional processing is
required to extract individual hit lists, since all results are merged into a
single file and must be separated programmatically.


### The `mspepsearchr` package

The `mspepsearchr` package provides an R interface to the MSPepSearch tool. It
was developed to overcome the practical limitations described above and to make
MSPepSearch fully accessible from within R. All major search options can be
specified directly via R function arguments. Less commonly used options (not yet
available as dedicated arguments) can be provided manually through the
`addl_cli_args` parameter, which is available in all relevant functions.

The MSPepSearch executables are included with this package, in compliance with
NIST's distribution policy. While including executables in an R package is
uncommon, this design provides two key benefits: improved user convenience (no
manual installation required) and automated testing support, ensuring reliable
and reproducible performance across platforms.

The package is available for Windows, Linux, and macOS. On Linux and macOS, Wine
must be installed and accessible via the system `$PATH` to run the Windows-based
MSPepSearch binaries.



## Library search algorithms

The package provides user-friendly access to all library search algorithms
available in NIST MS Search software for EI and MS/MS spectra of small
molecules. Supported algorithms and their corresponding functions include:

* Identity EI Normal - `IdentitySearchEiNormal()`
* Identity HighRes NoPrecursor - `IdentitySearchHighRes()`
* Identity MS/MS - `IdentitySearchMsMs()`
* Similarity EI Simple - `SimilaritySearchEiSimple()`
* Similarity EI Neutral Loss - `SimilaritySearchEiNeutralLoss()`
* Similarity EI Hybrid - `SimilaritySearchEiHybrid()`
* Similarity MS/MS in EI - `SimilaritySearchMsMsInEi()`
* Similarity MS/MS Hybrid - `SimilaritySearchMsmsHybrid()`

It is assumed that readers are familiar with the library search algorithms
provided by NIST. Detailed descriptions of these algorithms are available in the
package documentation and were adapted from the official MS Search help manual.
For the most complete and up-to-date information, users are encouraged to
consult the official NIST documentation.



## General functionality

The general functionality is illustrated here using the 'Identity EI Normal'
algorithm. The main principles are identical for other algorithms.

Assume that raw GC/MS data have been processed, and pure mass spectra of all
components have been extracted either manually (e.g., via background
subtraction) or automatically (e.g., with AMDIS, MZmine, or ChromaTOF). The
resulting spectra are saved in an MSP file. The path to this file can be
specified as either an absolute or relative path (the latter is convenient when
the spectra are in the same directory as the R script).

To use MSPepSearch, the mass spectral databases must be in NIST format.
Commercial databases are typically supplied in the correct format along with the
NIST MS Search software. For example, the NIST EI mass spectral library is
divided into two sub-libraries (*mainlib* and *replib*) `located` inside the
*MSSEARCH/* directory. The default installation path is typically
*C:/NISTxx/MSSEARCH/* (where `xx` is the version of the NIST database).
Therefore, to search against both *mainlib* and *replib* sub-libraries of
NIST23, the `libraries` argument can be specified as a character vector
`c("C:/NIST23/MSSEARCH/mainlib/", "C:/NIST23/MSSEARCH/replib/")`.

Most open-source mass spectral libraries, are distributed as MSP files. In such
cases, the library must first be converted to NIST format using MS Search
software or the Lib2NIST Converter tool. In the following example, a subset of
the Mass Bank database (already converted to NIST format) is used. To perform a
library search with default settings, the `spectra` and `libraries` arguments
must be provided.

``` {r identity_normal}
alkanes    <- system.file("extdata", "spectra", "alkanes_ei_lr.msp",
                             package = "mspepsearchr")
eims_lib <- system.file("extdata", "libraries", "massbank_subset_ei_lr_with_ri",
                        package = "mspepsearchr")
hitlists   <- IdentitySearchEiNormal(alkanes, eims_lib)
```

The resulting object (`hitlists`) is a list of data frames. Each data frame
represents the hit list obtained for a specific mass spectrum. The order of
spectra in the MSP file and in `hitlists` is identical, allowing indexing to
access specific hit list.

``` {r print_hitlist}
col_names <- c("name", "mf", "rmf", "prob", "formula", "mw", "inchikey", "cas")
head(hitlists[[4L]][, col_names], 3L)
```

The name of each mass spectrum is stored as the `unknown_name`
attribute of the corresponding hit list. This can be used to extract
results for a specific compound.

``` {r select_hitlist}
unknown_names <- vapply(hitlists, attr, which = "unknown_name", character(1L))
idx <- which(unknown_names == "Dodecane")
head(hitlists[[idx]][, col_names], 3L)
```



## Integration into other workflows

Mass spectra can be provided either as file paths (pointing to MSP or MGF files)
or directly as R objects. The latter is convenient when `mspepsearchr` is
integrated into existing workflows. When supplied as R objects, each spectrum is
represented as a list containing at least:

* `name` - a string containing the compound name or short description;
* `mz` - a numeric or integer vector of m/z values;
* `intst` - a numeric or integer vector of corresponding peak intensities.

Additional optional fields should follow MSP format conventions, for example,
molecular formula (`formula`), molecular weight (`mw`), exact mass
(`exactmass`), GC retention index (`retention_index`), and precursor ion m/z
(`precursormz`).

Using plain R lists instead of S4 objects simplifies integration with other R
packages and workflows. Lists are lightweight, easy to construct, and can be
converted from other data formats without extra dependencies.

The [LC-MS/MS data analysis with xcms][xcms_vignette] vignette provides a
detailed example of extracting a tandem mass spectrum from LC-MS/MS data. In
that vignette, a spectrum corresponding to a component with retention time
418.926 seconds was obtained from *PestMix1_DDA.mzML*. The example below
demonstrates how to convert an S4-class `Spectra` object into a format
compatible with `mspepsearchr`.


``` {r spectra_object, eval = FALSE}
ex_spectrum <- readRDS("data/ex_spectrum.rds")

data_origin <- Spectra::dataOrigin(ex_spectrum)
rtime <- Spectra::rtime(ex_spectrum)
ms_level <- Spectra::msLevel(ex_spectrum)
precursor_mz <- Spectra::precursorMz(ex_spectrum)
ion_mode <- switch(Spectra::polarity(ex_spectrum) + 1L, "NEGATIVE", "POSITIVE")
mz <- Spectra::mz(ex_spectrum)
intst <- Spectra::intensity(ex_spectrum)

fenamiphos <- lapply(seq_along(ex_spectrum), function(i) {
  list(name = paste0(basename(data_origin[[i]]), ", rt=", rtime[[i]], "s"),
       spectrum_type = paste0("MS", ms_level[[i]]),
       precursormz = precursor_mz[[i]],
       ion_mode = ion_mode[[i]],
       mz = mz[[i]],
       intst = intst[[i]])
})
```

For convenience, a pre-converted spectrum is also included in the package.

``` {r fenamiphos}
msp_path <- system.file("extdata", "spectra", "fenamiphos_msms_hr.msp",
                        package = "mspepsearchr")
fenamiphos <- mssearchr::ReadMsp(msp_path)

```

Once converted, the mass spectrum can be searched against a tandem mass spectral
library.

``` {r identity_msms}
msms_lib <- system.file("extdata", "libraries", "massbank_subset_msms_hr",
                        package = "mspepsearchr")
hitlists <-
  IdentitySearchMsMs(fenamiphos, msms_lib,
                     precursor_ion_tol  = list(value = 0.05, utits = "mz"),
                     product_ions_tol = list(value = 0.05, utits = "mz"))
col_names <- c("name", "dot", "rdot", "formula", "prec_mz", "delta_mz")
head(hitlists[[1L]][, col_names], 3L)
```

This approach enables seamless integration into automated workflows, allowing
direct library searches on spectra extracted from raw GC-MS or LC-MS/MS data
without the need to write or read intermediate MSP files.



## Setting search parameters with command-line flags

MSPepSearch offers extensive flexibility for adjusting search parameters and
controlling the output. These options are implemented through a large number of
command-line flags. While the most common parameters can be controlled via R
function arguments, less common options can be specified manually through the
`addl_cli_args` argument for fine-tuning.

The official MSPepSearch manual is a plain-text file named
*MSPepSearch64.exe.hlp.txt*. It can be accessed directly from R using the
`OpenHelpFile()` function, which opens it in the default text editor.

Passing additional flags via the `addl_cli_args` requires
caution, as only a minimal check for
duplicated flags is performed. Several potential issues are not automatically
detected:

* the presence of aliases (e.g., `v` and `/R.Match`);
* specifying tolerance in both m/z (`/M`) and ppm (`/MPPM`) simultaneously;
* misspelled flag names;
* incorrect sub-flag values;
* incompatible or conflicting flag combinations.

For example, attempting to manually specify the number of hits with `/HITS` will
raise an error, since this option is already managed automatically based on
`n_hits`.

``` {r error_duplicated_flags, eval = FALSE}
hitlists <- IdentitySearchEiNormal(spectra, ms_library,
                                   addl_cli_args = "/HITS 10")
#> Error in .PrepareJobs(spectra, libraries, algorithm = "identity_normal",  : 
#>   The following CLI flags are duplicated: /HITS
```

The use of the `addl_cli_args` argument is illustrated below using retention
indices (RI). The `ri_column_type` argument of `IdentitySearchEiNormal()` allows
specifying only the stationary phase type. However, MSPepSearch supports
additional RI-related options. For example, RI mismatches can be used to
penalize match factors. In the example below, the mass spectrum of tridecane
lacks low-intensity peaks (including the molecular ion), so the correct hit
appears only in the third position.

``` {r tridecane}
tridecane <- list(
  list(name = "Tridecane",
       mz = c(53, 55, 56, 57, 69, 70, 71, 84, 85),
       intst = c(51, 314, 220, 999, 110, 126, 526, 54, 274),
       retention_index = 1300)
)
hitlists <- IdentitySearchEiNormal(tridecane, eims_lib)
col_names <- c("name", "mf", "rmf", "prob", "formula", "mw", "ri")
head(hitlists[[1L]][, col_names], 3L)
```

By setting the RI tolerance to 15 i.u. (`t15`) and applying an infinite penalty
rate (`rIN`), all other normal alkanes are removed from the hit list, placing
tridecane at the top.

``` {r addl_cli_args, warning = FALSE}
hitlists <- IdentitySearchEiNormal(tridecane, eims_lib,
                                   addl_cli_args = "/RI nt15rIN")
head(hitlists[[1L]][, col_names], 3L)
```



## External parallelization

MSPepSearch is a single-threaded application. To improve performance, external
parallelization can be achieved by running multiple independent instances of
MSPepSearch from within R using the `parallel` package. The `n_threads` argument
specifies how many parallel threads to use for library searching.

Performance improvement is measured as speedup, defined as the ratio of
single-thread execution time to multi-thread execution time. As expected,
speedup depends on task complexity. In library searching, complexity is mainly
determined by the number of mass spectra to search and the size of the library.
Here, single-thread execution time serves as a practical indicator of task
complexity.

As shown in Figure 1, speedup increases monotonically with workload size.
Library searches were performed using the 'Identity EI Normal' algorithm on an
Intel Core i7-4790K with four threads. For simple tasks, the overhead of
parallelization dominates. Moderate tasks achieved speedups in the range of 2-3,
while computationally demanding tasks, requiring several minutes on a single
core, reached a the maximum speedup of approximately 3.4.

```{r}
#| label: fig_speedup_vs_complexity
#| echo: false
#| fig.cap: >
#|   Figure 1. Speedup obtained for various library search tasks using four
#|   threads as a function of task complexity (i.e., single-thread execution
#|   time). Representative tasks are encoded as three underscore-separated
#|   values: the number of unknown spectra, the mass spectral library and the
#|   presearch option. All searches used the 'Identity EI Normal' algorithm.

old_par <- par(no.readonly = TRUE)
on.exit(par(old_par))
par(mar = c(4.1, 4.1, 1.1, 1.1), cex = 0.9)

df <- readRDS("data/speedup_vs_task_complexity.rds")
cols <- c("#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3")
representative_tasks <- c("100_nist_off",
                          "2594_nist_default",
                          "500_nist_default",
                          "100_nist_default")
idxs <- match(representative_tasks, df$info)
plot(df$time_one_thread, df$speedup,
     pch = 21L, cex = 1.5, bg = "gray90",
     log = "x", xaxt = "n", yaxt = "n",
     xlab = "Execution time with one thread, s",
     ylab = "Speedup with four threads")
points(df$time_one_thread[idxs], df$speedup[idxs],
       pch = 21L, cex = 1.5, bg = cols)
x_ticks <- c(1, 10, 100, 1000)
y_ticks <- c(1, 2, 3)
axis(1, at = x_ticks, labels = x_ticks)
axis(2, at = y_ticks, labels = y_ticks[y_ticks])
rug(x = c(0.5, 1.5, 2.5, 3.5), ticksize = -0.03, side = 2)
legend(5900, 0.5, legend = representative_tasks,
       xjust = 1, yjust = 0,
       pch = 21L, pt.cex = 1.5, pt.bg = cols)
```

Figure 2 illustrates how speedup varies with the number of threads for several
representative library search tasks. The color scheme matches that of Figures 1.
For tasks of moderate to high complexity, speedup grows nearly linearly with the
number of threads up to four, which corresponds to the number of physical cores.
Beyond four threads, a noticeable slowdown occurs due to hyperthreading
overhead, a common phenomenon in parallel computing.

```{r}
#| label: fig_speedup_vs_num_threads
#| echo: false
#| fig.cap: >
#|   Figure 2. Speedup as a function of the number of threads for several
#|   representative library search tasks. Task complexity is represented by
#|   single-thread execution time.

old_par <- par(no.readonly = TRUE)
on.exit(par(old_par))
par(mar = c(4.1, 4.1, 1.1, 1.1), cex = 0.9)

df <- readRDS("data/speedup_vs_num_threads.rds")
n_bars <- length(unique(df$info))
x = matrix(df$speedup, nrow = n_bars, byrow = TRUE)
colnames(x) <- seq_len(ncol(x))
first_bar_x_pos <- 1.5 + (seq_len(ncol(x)) - 1) * (n_bars + 1)
bar_x_pos <- rep(first_bar_x_pos, n_bars) +
  rep(seq(0, by = 1, length.out = n_bars), each = 7L)
barplot(x,
        xlab = "Number of threads",
        ylab = "Speedup",
        ylim = c(0, max(x) + 0.2),
        col = c("#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3"),
        beside = TRUE,
        legend = c("3.8 min", "1.5 min", "17.9 s", "3.4 s"),
        args.legend = list(x = 0.5, y = max(x) + 0.1, xjust = 0))
arrows(x0 = bar_x_pos, x1 = bar_x_pos,
       y0 = df$speedup - df$speedup_err, y1 = df$speedup + df$speedup_err,
       code = 3, angle = 90, length = 0.04) # lwd = 2
box(bty = "l")
```



---

Built with `r r_info`.


[xcms_vignette]: <https://www.bioconductor.org/packages/release/bioc/vignettes/xcms/inst/doc/xcms-lcms-ms.html>

